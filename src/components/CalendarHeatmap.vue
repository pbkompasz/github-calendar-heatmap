<template>
  <div
    :class="{ 'container': true, 'dark-mode': darkMode, 'no-interact': noInteract, 'container--vertical': vertical === true }">
    <svg class="vch__wrapper" ref="svg" :viewBox="viewbox">

      <!-- MONTHS -->
      <g class="vch__months__labels__wrapper" :transform="monthsLabelWrapperTransform">
        <!-- Months that appear on the left side of the calendar -->
        <text class="vch__month__label" v-for="(month, index) in heatmap.firstFullWeekOfMonths" :key="index"
          :x="getMonthLabelPosition(month).x" :y="getMonthLabelPosition(month).y">
          <!-- {{ lo.months[month.value] }} -->
        </text>
      </g>

      <!-- DAYS -->
      <g class="vch__days__labels__wrapper" :transform="daysLabelWrapperTransform">
        <!-- Days that appear on the left side of the calendar -->
        <template v-for="i in Array(7).keys()" :key="i">
          <text class="vch__day__label" :x="vertical ? SQUARE_SIZE * i : 0"
            :y="vertical ? SQUARE_SIZE - SQUARE_BORDER_SIZE : (8 + i * SQUARE_SIZE)">
            <slot :name="'day-' + i">
              <template v-if="[1, 3, 5].includes(i)">
                <!-- {{ lo.days[i] }} -->
              </template>
            </slot>
          </text>
        </template>
      </g>

      <!-- VERTICAL CALENDAR -->
      <g v-if="vertical" class="vch__legend__wrapper" :transform="legendWrapperTransform">
        <text :x="SQUARE_SIZE * 1.25" y="8">{{ lo.less }}</text>
        <rect v-for="(color, index) in rangeColor" :key="index" :rx="round" :ry="round" :style="{ fill: color }"
          :width="SQUARE_SIZE - SQUARE_BORDER_SIZE" :height="SQUARE_SIZE - SQUARE_BORDER_SIZE" :x="SQUARE_SIZE * 1.75"
          :y="SQUARE_SIZE * (index + 1)" />
        <text :x="SQUARE_SIZE * 1.25" :y="SQUARE_SIZE * (rangeColor.length + 2) - SQUARE_BORDER_SIZE">
          {{ lo.more }}
        </text>
      </g>

      <!-- MAIN CALENDAR -->
      <g class="vch__year__wrapper" :transform="yearWrapperTransform">
        <g class="vch__month__wrapper" v-for="(week, weekIndex) in heatmap.calendar" :key="weekIndex"
          :transform="getWeekPosition(weekIndex)">
          <template v-for="(day, dayIndex) in week" :key="dayIndex">
            <rect class="vch__day__square" v-if="day.date < now" :rx="round" :ry="round"
              :transform="getDayPosition(dayIndex)" :width="SQUARE_SIZE - SQUARE_BORDER_SIZE"
              :height="SQUARE_SIZE - SQUARE_BORDER_SIZE" :style="{ fill: rangeColor[day.colorIndex] }"
              :data-tippy-content="tooltipOptions(day)" @click="emitEvent(day)" />
          </template>
        </g>
      </g>
    </svg>

    <!-- LEGEND -->
    <div v-if="!vertical"
      :class="`vch__legend legend-${(legendDirectionReverse ? (vertical ? 'bottom' : 'left') : (vertical ? 'top' : 'right'))}`">
      <div class="vch__legend">
        <slot name="legend-text-less">
          <div>{{ lo.less }}</div>
        </slot>
        <slot name="legend-range">
          <svg v-if="!vertical" class="vch__external-legend-wrapper" :viewBox="legendViewbox"
            :height="SQUARE_SIZE - SQUARE_BORDER_SIZE">
            <g class="vch__legend__wrapper">
              <rect v-for="(color, index) in rangeColor" :key="index" :rx="round" :ry="round"
                :style="{ fill: color }" :width="SQUARE_SIZE - SQUARE_BORDER_SIZE"
                :height="SQUARE_SIZE - SQUARE_BORDER_SIZE" :x="SQUARE_SIZE * index" />
            </g>
          </svg>
        </slot>
        <slot name="legend-text-more">
          <div>{{ lo.more }}</div>
        </slot>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { defineComponent, nextTick, onBeforeUnmount, onMounted, PropType, ref, toRef, toRefs, watch, computed, useSlots } from 'vue';
// @ts-ignore
import { CalendarItem, Heatmap, Locale, Month, TooltipFormatter, Value } from '@/components/Heatmap';
import tippy, { createSingleton, CreateSingletonInstance, Instance } from 'tippy.js';
import 'tippy.js/dist/tippy.css';
import 'tippy.js/dist/svg-arrow.css';

const props = defineProps({
  // Calendar end date
  endDate: {
    type: Date,
    // required: true,
    default: new Date(),
  },
  // DUNNO
  max: {
    type: Number
  },
  rangeColor: {
    type: Array as PropType<string[]>,
    default: Heatmap.DEFAULT_RANGE_COLOR_LIGHT,
  },
  // Main values
  values: {
    type: Array as PropType<Value[]>,
    required: true
  },
  locale: {
    type: Object as PropType<Partial<Locale>>
  },
  // Show tooltip
  tooltip: {
    type: Boolean,
    default: true
  },
  tooltipUnit: {
    type: String,
    default: Heatmap.DEFAULT_TOOLTIP_UNIT
  },
  tooltipFormatter: {
    type: Function as PropType<TooltipFormatter>
  },
  // Calendar orientation
  vertical: {
    type: Boolean,
    default: false
  },
  // Tooltip text on date with no data
  noDataText: {
    type: [Boolean, String],
    default: null
  },
  // Show no tooltip for empty dates
  noDataTooltip: {
    type: Boolean,
    default: false,
  },
  // Rounded corner for each date
  round: {
    type: Number,
    default: 0,
    validator: (val: Number) => {
      return (val >= 0 && val <= 5)
    },
  },
  darkMode: Boolean,
  // default is right if horizontal, top if vertical
  legendDirectionReverse: {
    type: Boolean,
    default: false,
  },
  // No hover effect, no tooltip, no click event emit
  noInteract: {
    type: Boolean,
    default: false,
  }
});
const emit = defineEmits(['dayClick']);
const SQUARE_BORDER_SIZE = Heatmap.SQUARE_SIZE / 5,
  SQUARE_SIZE = Heatmap.SQUARE_SIZE + SQUARE_BORDER_SIZE,
  LEFT_SECTION_WIDTH = Math.ceil(Heatmap.SQUARE_SIZE * 2.5),
  RIGHT_SECTION_WIDTH = SQUARE_SIZE * 3,
  TOP_SECTION_HEIGHT = Heatmap.SQUARE_SIZE + (Heatmap.SQUARE_SIZE / 2),
  BOTTOM_SECTION_HEIGHT = Heatmap.SQUARE_SIZE + (Heatmap.SQUARE_SIZE / 2),
  yearWrapperTransform = `translate(${LEFT_SECTION_WIDTH}, ${TOP_SECTION_HEIGHT})`,

  svg = ref<null | SVGElement>(null),
  now = ref(new Date()),
  heatmap = ref(new Heatmap(props.endDate as Date, props.values, props.max)),
  dayPositions = ref([8, 20, 32, 44, 56, 68, 80]),

  width = ref(0),
  height = ref(0),
  viewbox = ref('0 0 0 0'),
  legendViewbox = ref('0 0 0 0'),
  daysLabelWrapperTransform = ref(''),
  monthsLabelWrapperTransform = ref(''),
  legendWrapperTransform = ref(''),
  lo = ref<Locale>({} as any);

const { values, tooltipUnit, tooltipFormatter, noDataText, max, vertical, locale, legendDirectionReverse, rangeColor } = toRefs(props);


let tippyInstances: Instance[],
  tippySingleton: CreateSingletonInstance;

const initTippy = () => {
  tippyInstances = tippy(Array.from(svg.value!.querySelectorAll('.vch__day__square[data-tippy-content]')));
  if (tippySingleton) {
    tippySingleton.setInstances(tippyInstances);
  } else {
    tippySingleton = createSingleton(tippyInstances, {
      moveTransition: 'transform 0.1s ease-out',
      allowHTML: true
    });
  }
}

const slots = useSlots();
const tooltipOptions = (day: CalendarItem) => {
  return;
  if (props.tooltip && !props.noInteract) {
    // slots like: 'tooltip-2022-3-3'
    const tooltipForDate = `tooltip-${day.date.getFullYear()}-${day.date.getUTCMonth() + 1}-${day.date.getUTCDate()}`
    if (slots[tooltipForDate]) {
      console.log(slots[tooltipForDate]?.()[0])
      return slots[tooltipForDate]?.()[0].children
    }
    if (day.count !== undefined) {
      if (props.tooltipFormatter) {
        return props.tooltipFormatter(day, props.tooltipUnit);
      }
      if (slots['tooltip-active']) {
        return slots['tooltip-active']()[0].children
      }
      return `<b>${day.count} ${props.tooltipUnit}</b> ${lo.value.on} ${lo.value.months[day.date.getMonth()]} ${day.date.getDate()}, ${day.date.getFullYear()}`;
    } else if (props.noDataText) {
      return `${props.noDataText}`;
    } else if (props.noDataText !== false) {
      if (slots['tooltip-inactive']) {
        return slots['tooltip-inactive']()[0].children
      }
      return `<b>No ${props.tooltipUnit}</b> ${lo.value.on} ${lo.value.months[day.date.getMonth()]} ${day.date.getDate()}, ${day.date.getFullYear()}`;
    }
  }
  return undefined;
}

const getWeekPosition = (index: number) => {
  if (props.vertical) {
    return `translate(0, ${(SQUARE_SIZE * heatmap.value.weekCount) - ((index + 1) * SQUARE_SIZE)})`;
  }
  return `translate(${index * SQUARE_SIZE}, 0)`;
}

const getDayPosition = (index: number) => {
  if (props.vertical) {
    return `translate(${index * SQUARE_SIZE}, 0)`;
  }
  return `translate(0, ${index * SQUARE_SIZE})`;
}

const getMonthLabelPosition = (month: Month) => {
  if (props.vertical) {
    return { x: 3, y: (SQUARE_SIZE * heatmap.value.weekCount) - (SQUARE_SIZE * (month.index)) - (SQUARE_SIZE / 4) };
  }
  return { x: SQUARE_SIZE * month.index, y: SQUARE_SIZE - SQUARE_BORDER_SIZE };
}

watch([toRef(props, 'rangeColor'), toRef(props, 'darkMode')], ([rc, dm]) => {
  rangeColor.value = rc || (dm ? Heatmap.DEFAULT_RANGE_COLOR_DARK : Heatmap.DEFAULT_RANGE_COLOR_LIGHT);
});

watch(vertical, v => {
  if (v) {
    width.value = LEFT_SECTION_WIDTH + (SQUARE_SIZE * Heatmap.DAYS_IN_WEEK) + RIGHT_SECTION_WIDTH;
    height.value = TOP_SECTION_HEIGHT + (SQUARE_SIZE * heatmap.value.weekCount) + SQUARE_BORDER_SIZE;
    daysLabelWrapperTransform.value = `translate(${LEFT_SECTION_WIDTH}, 0)`;
    monthsLabelWrapperTransform.value = `translate(0, ${TOP_SECTION_HEIGHT})`;
  } else {
    width.value = LEFT_SECTION_WIDTH + (SQUARE_SIZE * heatmap.value.weekCount) + SQUARE_BORDER_SIZE;
    height.value = TOP_SECTION_HEIGHT + (SQUARE_SIZE * Heatmap.DAYS_IN_WEEK);
    daysLabelWrapperTransform.value = `translate(0, ${TOP_SECTION_HEIGHT})`;
    monthsLabelWrapperTransform.value = `translate(${LEFT_SECTION_WIDTH}, 0)`;
  }
}, { immediate: true });

watch([width, height], ([w, h]) => (viewbox.value = ` 0 0 ${w} ${h}`), { immediate: true });
watch([width, height, rangeColor], ([w, h, rc]) => {
  legendWrapperTransform.value = vertical.value
    ? `translate(${LEFT_SECTION_WIDTH + (SQUARE_SIZE * Heatmap.DAYS_IN_WEEK)}, ${TOP_SECTION_HEIGHT})`
    : `translate(${w - (SQUARE_SIZE * rc.length) - 30}, ${h - BOTTOM_SECTION_HEIGHT})`;
}, { immediate: true });

// watch(locale, l => (lo.value = l ? { ...Heatmap.DEFAULT_LOCALE, ...l } : Heatmap.DEFAULT_LOCALE), { immediate: true });
watch(rangeColor, rc => (legendViewbox.value = `0 0 ${Heatmap.SQUARE_SIZE * (rc.length + 1)} ${Heatmap.SQUARE_SIZE}`), { immediate: true });

watch(
  [values, tooltipUnit, tooltipFormatter, noDataText, max, rangeColor],
  () => {
    heatmap.value = new Heatmap(props.endDate as Date, props.values, props.max);
    tippyInstances?.map(i => i.destroy());
    nextTick(initTippy);
  }
);

onMounted(() => {
  initTippy()
});

onBeforeUnmount(() => {
  tippySingleton?.destroy();
  tippyInstances?.map(i => i.destroy());
});

const emitEvent = (day: any) => {
  if (!toRef(props, 'noInteract'))
    emit('dayClick', day)
}
</script>

<style lang="scss">
.no-interact {
  Text-Decoration: None !important;
  pointer-events: none;
}

.container {
  max-width: 675px;
}

.container--vertical {
  max-width: 145px;
}

.vch__container {
  max-width: 675px;
  .vch__legend {
    display: flex;
    justify-content: space-between;
    align-items: center;

    &.legend-left {
      flex-direction: row;
    }

    &.legend-right {
      flex-direction: row-reverse;
    }
  }

  .vch__external-legend-wrapper {
    margin: 0 8px;
  }
}

svg.vch__wrapper {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 10px;
  width: 100%;

  .vch__months__labels__wrapper text.vch__month__label {
    font-size: 10px;
  }

  .vch__days__labels__wrapper text.vch__day__label,
  .vch__legend__wrapper text {
    font-size: 9px;
  }

  text.vch__month__label,
  text.vch__day__label,
  .vch__legend__wrapper text {
    fill: #767676;
  }

  rect.vch__day__square:hover {
    stroke: #555;
    stroke-width: 2px;
    paint-order: stroke;
  }

  rect.vch__day__square:focus {
    outline: none;
  }

  &.dark-mode {

    text.vch__month__label,
    text.vch__day__label,
    .vch__legend__wrapper text {
      fill: #fff;
    }
  }
}
</style>
